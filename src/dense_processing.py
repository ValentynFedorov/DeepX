"""
Advanced Dense Point Cloud Processing Module.

This script provides fine-grained control over the post-processing of
dense point clouds generated by COLMAP. It includes algorithms for:
1. Statistical Outlier Removal (Denoising).
2. RANSAC Plane Segmentation (Removing tables/ground).
3. DBSCAN Clustering (Isolating the main object).
4. Normal Estimation (Improving rendering quality).

Usage:
    python process_dense.py --input workspace/dense/fused.ply --visualize-plane
"""

import argparse
import numpy as np
import open3d as o3d
from pathlib import Path


class DenseProcessor:
    """
    Static utility class for advanced point cloud manipulation.
    """

    @staticmethod
    def display_inlier_outlier(cloud, ind):
        """
        Visualizes the segmentation result.

        Args:
            cloud (o3d.geometry.PointCloud): The original point cloud.
            ind (list): Indices of the inliers (points to keep/highlight).
        """
        inlier_cloud = cloud.select_by_index(ind)
        outlier_cloud = cloud.select_by_index(ind, invert=True)

        outlier_cloud.paint_uniform_color([0.8, 0.8, 0.8]) # Object
        inlier_cloud.paint_uniform_color([1, 0, 0])      # Plane

        print("[VISUALIZATION] Red = Plane (Removing), Grey = Object (Keeping)")
        o3d.visualization.draw_geometries(
            [inlier_cloud, outlier_cloud],
            window_name="Plane Segmentation Debugging",
            width=1024, height=768
        )

    @staticmethod
    def remove_statistical_outliers(pcd, nb_neighbors=20, std_ratio=2.0):
        """
        Removes sparse noise points using Statistical Outlier Removal (SOR).

        Args:
            pcd (o3d.geometry.PointCloud): Input cloud.
            nb_neighbors (int): Number of neighbors to analyze for each point.
            std_ratio (float): Threshold (std dev) to consider a point an outlier.

        Returns:
            o3d.geometry.PointCloud: Denoised cloud.
        """
        print("Step 1: Removing Noise (Statistical Outlier Removal)")
        print(f"Original points: {len(pcd.points):,}")

        cl, ind = pcd.remove_statistical_outlier(
            nb_neighbors=nb_neighbors,
            std_ratio=std_ratio
        )
        pcd_clean = pcd.select_by_index(ind)

        removed = len(pcd.points) - len(pcd_clean.points)
        print(f"Removed {removed:,} noise points")
        print(f"Points after noise removal: {len(pcd_clean.points):,}")

        return pcd_clean

    @staticmethod
    def remove_plane(pcd, distance_threshold=0.02, ransac_n=3, num_iterations=1000, visualize=False):
        """
        Segments and removes the largest planar surface (e.g., table) using RANSAC.

        Args:
            pcd (o3d.geometry.PointCloud): Input cloud.
            distance_threshold (float): Max distance a point can be from the plane model.
            ransac_n (int): Number of points to sample per iteration.
            num_iterations (int): Max RANSAC iterations.
            visualize (bool): If True, shows the plane in red before removing.

        Returns:
            o3d.geometry.PointCloud: Cloud with the plane removed.
        """
        print("Step 2: Removing Table/Floor (RANSAC Plane Segmentation)")

        plane_model, inliers = pcd.segment_plane(
            distance_threshold=distance_threshold,
            ransac_n=ransac_n,
            num_iterations=num_iterations
        )

        [a, b, c, d] = plane_model
        print(f"Plane equation: {a:.4f}x + {b:.4f}y + {c:.4f}z + {d:.4f} = 0")
        print(f"Plane contains {len(inliers):,} points")

        if visualize:
            DenseProcessor.display_inlier_outlier(pcd, inliers)

        object_pcd = pcd.select_by_index(inliers, invert=True)
        print(f"Points after plane removal: {len(object_pcd.points):,}")

        return object_pcd

    @staticmethod
    def extract_largest_cluster(pcd, eps=0.05, min_points=10):
        """
        Isolates the main object using DBSCAN clustering.

        Args:
            pcd (o3d.geometry.PointCloud): Input cloud.
            eps (float): Density parameter (max distance between points in a cluster).
            min_points (int): Min points to form a cluster.

        Returns:
            o3d.geometry.PointCloud: The largest remaining cluster.
        """
        print("Step 3: Isolating Main Object (DBSCAN Clustering)")

        # Use VerbosityContextManager to suppress Open3D internal spam
        with o3d.utility.VerbosityContextManager(o3d.utility.VerbosityLevel.Debug) as cm:
            labels = np.array(pcd.cluster_dbscan(
                eps=eps,
                min_points=min_points,
                print_progress=True
            ))

        max_label = labels.max()
        print(f"Found {max_label + 1} clusters")

        if max_label < 0:
            print(" Warning: No clusters found, returning original cloud")
            return pcd

        # Find largest cluster
        counts = np.bincount(labels[labels >= 0])
        largest_cluster_idx = np.argmax(counts)

        print(f"Largest cluster: Index {largest_cluster_idx} with {counts[largest_cluster_idx]:,} points")

        ind = np.where(labels == largest_cluster_idx)[0]
        final_object = pcd.select_by_index(ind)

        return final_object

    @staticmethod
    def estimate_normals(pcd, radius=0.1, max_nn=30):
        """
        Computes normals for the point cloud to enable lighting effects.

        Args:
            pcd (o3d.geometry.PointCloud): Input cloud.
            radius (float): Search radius for normal estimation.
            max_nn (int): Max neighbors to consider.

        Returns:
            o3d.geometry.PointCloud: Cloud with normals.
        """
        print("Step 4: Estimating Normals")
        pcd.estimate_normals(
            search_param=o3d.geometry.KDTreeSearchParamHybrid(
                radius=radius,
                max_nn=max_nn
            )
        )
        print(f"Normals computed for {len(pcd.normals):,} points")
        return pcd

    @staticmethod
    def clean_point_cloud_advanced(input_path, output_path=None,
                                   remove_noise=True, remove_plane=True,
                                   extract_cluster=True, compute_normals=True,
                                   visualize_plane=False):
        """
        Orchestrates the full cleaning pipeline.
        """
        input_path = Path(input_path)

        if not input_path.exists():
            raise FileNotFoundError(f"File not found: {input_path}")

        print(f"Loading {input_path}...")
        pcd = o3d.io.read_point_cloud(str(input_path))
        print(f"Loaded {len(pcd.points):,} points")

        if remove_noise:
            pcd = DenseProcessor.remove_statistical_outliers(pcd)

        if remove_plane:
            pcd = DenseProcessor.remove_plane(pcd, visualize=visualize_plane)

        if extract_cluster:
            pcd = DenseProcessor.extract_largest_cluster(pcd)

        if compute_normals:
            pcd = DenseProcessor.estimate_normals(pcd)

        if output_path:
            output_path = Path(output_path)
            o3d.io.write_point_cloud(str(output_path), pcd)
            print(f"\nSaved cleaned model to {output_path}")

        return pcd

    @staticmethod
    def visualize_advanced(pcd, window_name="High-Quality Point Cloud",
                           background_color=[0.1, 0.1, 0.1], point_size=2.0):
        """
        Runs a high-quality visualizer window.
        """
        print(f"\nVisualizing: {window_name}")

        vis = o3d.visualization.Visualizer()
        vis.create_window(window_name=window_name, width=1280, height=720)
        vis.add_geometry(pcd)

        opt = vis.get_render_option()
        opt.background_color = np.asarray(background_color)
        opt.point_size = point_size
        opt.show_coordinate_frame = True

        if pcd.has_colors():
            print("Point cloud has colors")
        if pcd.has_normals():
            print("Point cloud has normals")

        print("Close window to continue")
        vis.run()
        vis.destroy_window()

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Advanced Dense Cloud Processing")
    parser.add_argument("--input", type=str, default="workspace/dense/fused.ply", help="Path to input PLY")
    parser.add_argument("--output", type=str, default="cleaned_book.ply", help="Path to output PLY")

    # Flags to control pipeline steps
    parser.add_argument("--visualize-plane", action="store_true", help="Visualize plane segmentation")
    parser.add_argument("--no-noise-removal", action="store_true", help="Skip noise removal")
    parser.add_argument("--no-clustering", action="store_true", help="Skip DBSCAN clustering")

    # Visualization options
    parser.add_argument("--point-size", type=float, default=2.0, help="Point size for visualization")

    args = parser.parse_args()

    processor = DenseProcessor()

    try:
        cleaned_pcd = DenseProcessor.clean_point_cloud_advanced(
            input_path=args.input,
            output_path=args.output,
            remove_noise=not args.no_noise_removal,
            remove_plane=True,
            extract_cluster=not args.no_clustering,
            compute_normals=True,
            visualize_plane=args.visualize_plane
        )

        DenseProcessor.visualize_advanced(
            cleaned_pcd,
            window_name="Processed Result",
            point_size=args.point_size
        )

    except FileNotFoundError as e:
        print(f"Error: {e}")
        print("Please run the main reconstruction pipeline first, or provide a valid --input path.")